В любом языке программирования есть такая штука, как переменные. 
То есть это ссылки на места в оперативной памяти, где лежит значение, которое может меняться — например, когда ты пишешь после переменной знак равно (оператор присваивания) и какое-то новое значение.

Ключевое слово “if” используется для ситуаций, когда нам нужно выполнить разные действия при положительных или отрицательных условиях. При значении “истинно” будет выполняться описанный после слова “if” блок.
Использование elif, который означает что-то вроде ИНАЧЕ-ЕСЛИ. Это применяется для задания нескольких блоков команд: в случае, если одно условие не выполняется, с помощью ELIF проверяется следующее и так далее.
Блок “else” выполнится при условии, если условие “if” ложно.


Цикл While: до тех пор, пока условие истинно, код внутри цикла будет выполняться.

Если просто нужно выполнить команды заранее известное количество раз, то используй цикл for и функцию range().


В языке программирования Python есть арифметические, логические и операторы сравнения.

Арифметические операторы: 
сложение +
вычитание -
умножение *
деление /
взятие остатка от деления print(1 % 2) # Взятие остатка от деления на 2
деление нацело  print(91 // 10) # Деление нацело на 10
возведение в степень print(2 ** 3) # Возведение в степень числа 2

Сравнения орепаторы:
Оператор равенства == возвращает True, если числа равны, и False в противном случае.
Оператор неравенства != возвращает True, если числа не равны, и False в противном случае.
Оператор больше > возвращает True, если первое число больше второго, и False в противном случае.
Оператор меньше < возвращает True, если первое число меньше второго, и False в противном случае.
Оператор меньше или равно <= возвращает True, если первое число меньше второго или равно ему, и False в противном случае.
Оператор больше или равно >= возвращает True, если первое число больше второго или равно ему, и False в противном случае.

Логические операторы:
оператор and (оператор логического умножения, конъюнкция). Если хотя бы один из операторов равен False, то результат оператора будет равен False. Конъюкция истинна в том случае, когда все условия истинны.
Логическое сложение (дизъюнкция) или оператор or требует выполнения ХОТЯ БЫ одного условия.
Оператор инверсии not изменяет (инвертирует) значение на противоположное. Оператор not выполняется в приоритете.


Словарь — неупорядоченная структура данных, которая позволяет хранить пары «ключ — значение».
Для получения значения конкретного ключа используются квадратные скобки [].
Для удаления ключа и соответствующего значения из словаря можно использовать del
Метод get() возвращает значение по указанному ключу. Если указанного ключа не существует, метод вернёт None. Также можно указать значение по умолчанию, которое будет возвращено вместо None, если ключа в словаре не окажется.

student = dict(name='Ivan', age=12)

print(student.get('name'))     # -> Ivan
print(student.get('lastname')) # -> None
print(student.get('lastname', 'No key')) # -> No key

Метод pop() удаляет ключ и возвращает соответствующее ему значение.
sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

model = sneakers.pop('model')

print(sneakers) # -> {'brand': 'Adidas', 'price': '9990 RUB'}
print(model)    # -> Nite Jogger

Метод keys() возвращает специальную коллекцию ключей в словаре.
sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

print(sneakers.keys()) # -> dict_keys(['brand', 'price', 'model'])

# dict_keys - это неизменяемая коллекция элементов.

keys = list(sneakers.keys())
print(keys) # -> ['brand', 'price', 'model']

Метод values() возвращает специальную коллекцию значений в словаре.
sneakers = dict(brand='Adidas', price='9990 RUB', model='Nite Jogger')

print(sneakers.values()) # -> dict_values(['Adidas', '9990 RUB', 'Nite Jogger'])

# dict_values - это неизменяемая коллекция элементов.

values = list(sneakers.values())
print(values) # -> ['Adidas', '9990 RUB', 'Nite Jogger']

Метод items() возвращает пары «ключ — значение» в формате кортежей.
Метод setdefault() возвращает значение ключа, но если его нет, создает ключ с указанным значением (по умолчанию None).

